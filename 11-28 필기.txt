■어제 배웠던 내용 복습

	1. 클래스 변수와 인스턴스 변수

		클래스변수와 인스턴스 변수의 차이?

		"고정 변수와 비 고정 변수"

	2. 기초 통계에 필요한 함수

		데이터를 대표할 수 있는 값중에 중심성향을 나타내는 값
			- 평균값 : 평균값
			- 중앙값 : 데이터의 가운데 값
			- 최빈값 : 빈도수가 많은 값
			- 분산	 : 데이터의 퍼짐의 정도
			- 표준편차 : 평균과의 오차
			- 범위	 : 최대값 - 최소값
			- 사분위수 범위 : 데이터의 25% ~ 75% 사이의 데이터

	3. 파이썬으로 그래프 그리는 방법

		- 라인 그래프
		- 막대 그래프
		- 원형 그래프
		- plot 그래프
		- 히스토그램 그래프
		- 사분위수 그래프

	특급 엔지니어
		여러 회사들을 돌아다니면서 쌓은 노하우를 스크립트로 가지고 다님

			1. 우리의 지식을 잘 정리한 블로그(홈페이지)
			2. 자기만의 스크립트





■ 51. 클래스 메소드 이해하기 ②

	"기초 통계에 필요한 함수들을 가지고 class를 생성"

	예 : 
		stats = stats()
		
		a = [24, 23, 21, 20, 30, 44, 41]
		
		stats.mean(a)


문제 190. mean함수를 생성해서 아랴와 같이 수행하면 실행되게 하시오 !

	a = [24, 23, 21, 20, 30, 44, 41]
		
	print(mean(a))

	내 답 :
		def mean(data):
		    num = 0
		    for i in data:
		        num += i
		    return num/len(data)

	선생님 답 :
		def mean(data):
		    return sum(data)/len(data)
	


문제 191. Stats라는 클래스를 만들고 Stats클래스 안에 mean메소드를 추가하여 아래와 같이 실행되게 하시오 !

	class Stats:
	    
	    def mean(self, data):
	        return sum(data)/len(data)
	
	stats1 = Stats()
	
	a = [24, 23, 21, 20, 30, 44, 41]
	
	print( stats1.mean(a) )


문제 192. 분산 함수를 생성하시오 !

	* 분산 : 데이터의 퍼짐 정도

	1공식
		def varience(data):
		    avg = sum(data)/len(data)
		    num = 0
		    for i in data:
		        num += (i - avg)**2
		    return num/len(data)

	2공식
		def varience(self, data):
		    avg = mean(data)
		    num = 0
		    for i in data:
		        num += i**2
		    avg_2 = num/len(data)
		    return avg_2 - avg**2


문제 193. 표준편차를 구하는 함수를 생성하시오 !

	* 표준편차 ? 평균과의 오차(분산에 루트를 씌운것)
		import math
		print( math.sqrt(4))

	실행 결과 : 

		def mean(data):
		    return sum(data)/len(data)
		def varience(data):
		    avg = mean(data)
		    num = 0
		    for i in data:
		        num += i**2
		    avg_2 = num/len(data)
		    return avg_2 - avg**2
		
		def stddev(data):
		    var = varience(data)
		    std = var**0.5
		    return std
		print( stats1.stddev(a) )



문제 194. 중앙값을 구하는 함수를 생성하시오 
	  ( 어제 배웠던 numpy 이용해서 구현 )
	
	a = [24,23,21,20,30,44,41]
	print( median(a) )
	
	답:
	def median(args) :
	    import numpy as np
	    a = np.array(args)
	    b = np.median(a)
	    return b
	
	a = [24,23,21,20,30,44,41]
	print( median(a) )
	
	-- 넘파이 이용하지 않은 코드 :
	
	def median(lst):
	    lst.sort()
	    if len(lst)%2==0 :
	        return (lst[int(len(lst)/2)-1]+lst[int((len(lst)/2)+1)-1])/2
	    else:
	        return lst[int((len(lst)/2)-0.5)]



문제 195. 최빈값을 구하는 함수를 생성하시오 !

	age_9 = [ 2,2,2,2,2,2,2,2,2,2, 52,52,52,52,52,52,52,52,52,52]

	def mode(data):
	    dis_data = list(set(data))
	    cnt = 0
	    mod = []
	    mod_data = []
	    for i in dis_data:
	        for j in data:
	            if i == j:
	                cnt += 1
	        mod.append(cnt)
	        cnt = 0
	    mod_index = 0
	    data_mod_index = []
	    for i in mod:
	        if max(mod) == i:
	            data_mod_index.append(mod_index)
	        mod_index += 1
	    result =[]
	    for i in data_mod_index:
	        result.append(dis_data[i])
	    return result




문제 196. (점심시간 문제) 위에서 만든 기초통계 함수들을 가지고 통계 클래스(Stats)를 생성하시오!

	class Stats:
	    def __init__(self):
	        print('통계 객체가 생성되었습니다.')
	    def mean(self, data):
	        return sum(data)/len(data)
	
	    def varience(self, data):
	        avg = self.mean(data)
	        num = 0
	        for i in data:
	            num += i**2
	        avg_2 = num/len(data)
	        return avg_2 - avg**2
	
	    def stddev(self, data):
	        var = self.varience(data)
	        std = var**0.5
	        return std
	
	    def median(self, args) :
	        import numpy as np
	        a = np.array(args)
	        b = np.median(a)
	        return b
	    
	    def mode(self, data):
	        dis_data = list(set(data))
	        cnt = 0
	        mod = []
	        mod_data = []
	        for i in dis_data:
	            for j in data:
	                if i == j:
	                    cnt += 1
	            mod.append(cnt)
	            cnt = 0
	        mod_index = 0
	        data_mod_index = []
	        for i in mod:
	            if max(mod) == i:
	                data_mod_index.append(mod_index)
	            mod_index += 1
	        result =[]
	        for i in data_mod_index:
	            result.append(dis_data[i])
	        return result
	
	a = [24, 23, 21, 20, 30, 44, 41]
	stats1 = Stats()
	print (stats1.mean(a))
	print (stats1.median(a))
	print (stats1.mode(a))
	print (stats1.varience(a))
	print (stats1.stddev(a))



문제 197. 위에서 만든 기초 통계 클래스를 모듈화 해서 아래와 같이 다른창에 실행되게 하시오 !

	import My_Stats as m
	a = [24, 23, 21, 20, 30, 44, 41]
	stats1 = m.My_Stats()
	print(stats1.stddev(a))

	통계 객체가 생성되었습니다.
	9.071147352221455

		★★★ 꿀팁 ! Ctrl + 함수 클릭하면 원래의 모듈파일이 열린다. ★★★



문제 198. range 함수와 percent_range(사분위 범위) 함수를 각각 My_Stats클래스에 추가하시오!

	    def range(self, data):
	        return max(data) - min(data)
	    
	    def percent_range(self, args):
	        result = np.quantile(args, 0.75) - np.quantile(args, 0.25)
	        return result








■ 52. 클래스 생성자

	"객체가 만들어질 때 호출되는 함수를 생성자(__init__)라고 한다."

	 생성자는 초기화 할때 자주 사용한다.

	예제 : 
		class My_Stats:
		    def __init__(self):
		        print('통계 객체가 생성되었습니다.')




■ 53. 클래스 소멸자 이해하기

	"객체가 사라질 때 호출되는 함수를 소멸자 (__del__)라고 한다.

	예제 :
		class Myclass:
		    def __init__(self):
		        self.var = '안녕하세요 !'
		        print('Myclass 인스턴스 객체가 생성되었습니다.')
		        
		    def __del__(self):
		        print('Myclass 인스턴스가 메모리에서 제거됩니다.')
		        
		object1 = Myclass()
		del object1








■ 54. 클래스 상속 이해하기

	상속이란 ? 클래스들 끼리 유산(기능) 을 물려주는 것

		부모 클래스  -------------> 자식 클래스 
				기능

		상속을 받게 되면 부모의 기능을 굳이 자식 클래스에 코딩을 하지 않아도 된다.

	예제 :		       Card 클래스
	 		     ↙		  ↘
		영화할인 card		    마트 할인 card


	예제1 : 
		class father:
		    def base_method(self):
		        print('hello~~~~~')
		
		class child(father):
		    pass
		
		father = father()
		father.base_method()
		
		child = child()
		child.base_method()


	☆ 오버라이드 : 자식 클래스에서 부모클래스의 함수를 가져와서 수정하면 부모클래스의 함수를 무시하고
			자식 클래스의 함수로 적용되게 하는 것을 말한다.



문제 199. 아래의 카드사의 상속코드를 구현하기 위해서 먼저 부모 클래스인 Card클래스를 구현하시오 !

			       Card 클래스
	 		     ↙		  ↘
		영화할인 card		    마트 할인 card

	구현 내용 : card의 기본 기능
			1. __init__함수 : 카드 발급시 카드가 발급되었습니다. 메세지 출력
			2. 충전 기능 (charge)
			3. 소비 기능 (consume)
				"잔액부족 메세지 출력"
			4. 잔액 프린트 기능(print)

	class Card:
	    def __init__(self):
	        self.card = 0
	        
	    def charge(self, num):
	        self.card += num
	        print('{}원 충전되었습니다.'.format(num))
	    
	    def consume(self, num, loc):
	        self.card -= num
	        if self.card <= 0:
	            self.card += num
	            print('잔액이 부족합니다.')
	        else:
	            print('{}에서 {}원 사용했습니다.'.format(loc, num))
	
	    def print(self):
	        print('잔액이 {}원 입니다.'.format(self.card))



문제 200. 부모 클래스인 Card클래스의 기능을 상속받아서 영화할인 카드 클래스를 생성하시오 !
	  (영화 할인 20%로 해서 생성하시오)

	1. 그냥 그대로 상속 받은 버전의 코드
		class Movie_card(Card):
		    pass

	2. 오버라이드한 버전의 코드 (부모 consume안쓰고 내꺼 쓰겟다는 뜻)
		class Movie_card(Card):
		    pass
		
		    def consume(self, num, loc):
		        if loc == '영화관':
		            num = num*0.8
		        self.card -= num
		        if self.card <= 0:
		            self.card += num
		            print('잔액이 부족합니다.')
		        else:
		            print('{}에서 {}원 사용했습니다.'.format(loc, num))

	

문제 201. 마트 할인 카드 클래스를 생성하시오 ! (할인율 10%)

	class Mart_card(Card):
	    pass
	
	    def consume(self, num, loc):
	        if loc == '마트':
	            num = num*0.9
	        self.card -= num
	        if self.card <= 0:
	            self.card += num
	            print('잔액이 부족합니다.')
	        else:
	            print('{}에서 {}원 사용했습니다.'.format(loc, num))



문제 202. 손자 Card를 생성하시오 !
	  (영화_마트_교통 Card를 생성하시오)

			"죽음의 다이아몬드 상속"
	예제 : 
			       Card    클래스
	 		     ↙		     ↘
		영화할인 card		       마트 할인 card
			     ↘		     ↙
			       영화_마트_교통


class Movie_mart_trans_card(Movie_card,Mart_card):
    def consume(self, num, loc):
        if loc == '교통':
            num = num*0.7
            self.card -= num
            if self.card <= 0:
                self.card += num
                print('잔액이 부족합니다.')
            else:
                print('{}에서 {}원 사용했습니다.'.format(loc, num))
        elif loc == '마트':
            Mart_card.consume(self, num, loc)
        elif loc == '영화관':
            Movie_card.consume(self, num, loc)
        else:
            Card.consume(self, num, loc)













■ 다중 상속 

	다중 상속이란 두개 이상의 클래스를 상속 받는것을 말한다. 이 경우에는 두 클래스의 모든 속성을 
	물려받게 된다. 이는 하나의 자식 클래스가 두개 이상의 부모 클래스를 가지는것이라고 할 수 있다.

	       father1        father2 
	             ↘     ↙
	               child  

	예제:
	
		class  father1:
		    def  func(self):
		        print("지식")
		
		class father2:
		    def func(self):
		        print('지혜')
		
		class child(father1, father2):
		    def childfunc(self):
		        father1.func(self)
			father2.func(self)
		
		child1 = child()
		child1.childfunc()


★ 다중 상속시 주의할 점	"죽음의 다이아몬드 상속"

			grandfather
		      ↙          ↘
	       father1              father2 
	              ↘          ↙
	                   child  
	예제 : 
		class grandfather:
		    def __init__(self):
		       print('튼튼한 두팔')
		
		class father1(grandfather):
		    def __init__(self):
		        grandfather.__init__(self)
		        print("지식")
		
		class father2(grandfather):
		    def __init__(self):
		        grandfather.__init__(self)
		        print("지혜")
		
		class grandchild(father1,father2):
		    def __init__(self):
		        father1.__init__(self)
		        father2.__init__(self)
		        print('자기 만족도가 높은 삶') 
		
		grandchild = grandchild()

	결과 : 
		튼튼한 두팔
		지식
		튼튼한 두팔
		지혜
		자기 만족도가 높은 삶

	설명 : 팔이 4개가 되어버렸다. 다중상속시 주의할 점 이다. 그래서 팔이 한번만 출력되게 하려면
	       super를 사용해야 한다.

	class grandfather:
	    def __init__(self):
	       print('튼튼한 두팔')
	
	class father1(grandfather):
	    def __init__(self):
	        print("지식")
	        super().__init__()
	
	class father2(grandfather):
	    def __init__(self):
	        print("지혜")
	        super().__init__()
	
	class grandchild(father1,father2):
	    def __init__(self):
	        super().__init__()
	        print('자기 만족도가 높은 삶') 
	
	grandchild = grandchild() 



















