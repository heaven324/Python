■ 파이썬 ncs 시험 2가지

	1. 빅데이터 수집 (웹스크롤링) - 포트폴리오	(1월 4일 제출)

	- 포트폴리오에 대한 설명
	
		1. 주제(제목)	12/21 까지 카페 댓글로
	      
			2. 빅데이터를 수집하는 이유
			3. 수집 대상 웹페이지
			4. 수집할 때 사용한 모듈과 수집방법 기술
			5. 수집한 데이터로 어떠한 분석을 할 것인지 설명
				- 코드
				- 데이터
				- 웹스크롤링하는 과정에 대한 동영상 캡쳐

	2. 빅데이터 입출력 구현(판다스) 










■ 162 ~ 172. 웹스크롤링

	1. 웹 스크롤링 기본 문법
	2. ebs 레이디 버그 게시판 댓글 스크롤링
	3. 한겨례 신문사 웹 스크롤링 코드 구현
	4. 중앙일보 신문사
	5. 동아일보 신문사

		주가에 영향을 주는 요소 빅데이터
			기사를 읽는 인공지능 신경망(아직 없음)
			( 미래에셋 로보 어드바이져 )
 
	6. 이미지(사진) 데이터 스크롤링
		- 네이버
		- 구글
		- 빙
		- 다음

	서울시 응답소 게시판 (Javascript 포함)



■ 서울시 응답소 게시판 웹 스크롤링

	서울시 응답소 게시판 주소
	http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp

문제397. 서울시 응답소 게시판의 글을 웹스크롤링 하기 위해 페이지마다 html코드를 가져올 수 있도록 하시오 !

	<a href="javascript:commonPagingPost('2','10','Shr01_lis.jsp');" title="2페이지">2</a>
	
	commonPagingPost    <=-----  자바 스크립트 함수
	

		import  urllib.request
		from  bs4 import  BeautifulSoup
		import  os
		import  re
		
		def  fetch_list_url():
		    params = []
		    for  j  in  range(1,30):
		        list_url ="http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
		        request_header = urllib.parse.urlencode({"page": j})
		        print (request_header) 
		
		fetch_list_url() 
		
		#javascript:commonPagingPost('2','10','Shr01_lis.jsp');
		#
		#   function commonPagingPost (Page, Block, Action) {
		#            var Frm = document.mainForm;
		#            Frm.RCEPT_NO.value = "";
		#            Frm.page.value = Page;
		#            Frm.action = Action;
		#            Frm.submit ();
		#         }
		#      -->
		#      </script>



문제 398. 아래의 서울시 응답소 게시판 url과 페이지번호를 commonPagingPost자바스크립트 함수에 제공을 해야 
	  해당 페이지의 html코드를 내려받을 수 있다.

	import  urllib.request
	from  bs4 import  BeautifulSoup
	import  os
	import  re
	
	def  fetch_list_url():
	    for  j  in  range(1,30):
	        list_url ="http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
	        request_header = urllib.parse.urlencode({"page": j})
	        # print(request_header) page = 1, page=2 ... 가 출력됨 
	
	        request_header = request_header.encode("utf-8")		# 컴퓨터가 알아볼 수 있는 언어로 인코딩
	        # page=1 을 컴퓨터가 이해할수 있는 이진 코드로 변환 
	        # print (request_header)  #   b'page=1'  출력 
	
	        url = urllib.request.Request( list_url, request_header )	# 페이지번호 같이 제공
	        res = urllib.request.urlopen(url).read().decode("utf-8")	# res에 html코드가 담김
	        print (res)  


	fetch_list_url() 



문제 399. 문재인 대통령 기사를 이름은 최재혁으로 사진도 최재혁으로 변경하시오 !







------------------------------------------------------------
http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp

	page=1, page=2, page=3 ........
		↓
자바 스크립트 함수 : commonPagingPost   ----> html코드를 보내준다

			↓   게시글을 클릭했을 때 바뀌는 url

http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_vie.jsp

자바 스크립트 함수 : JavaScript:onView
------------------------------------------------------------



문제 400. 게시글의 상세 게시판글을 스크롤링 하기 위해서 필요한 상세 url에 해당하는 코드(javascript함수에 제공해야 하는 코드)를 스크롤링하시오 !

	<a href="JavaScript:onView ('20181126905228')" title="도시기반시설본부 면허과다 제한 및 공동도급 
	불허 개선 "> 도시기반시설본부 면허과다 제한 및 공...</a>

	 JavaScript:onView ('20180801905041')
	                        ↑
	                  이 부분을 스크롤링 해야한다. 

		import  urllib.request
		from  bs4 import  BeautifulSoup
		import  os
		import  re
		
		def  fetch_list_url():
		    for  j  in  range(1,10):
		        list_url ="http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
		        request_header = urllib.parse.urlencode({"page": j})
		        # print(request_header) page = 1, page=2 ... 가 출력됨 
		
		        request_header = request_header.encode("utf-8")
		        # page=1 을 컴퓨터가 이해할수 있는 이진 코드로 변환 
		        # print (request_header)  #   b'page=1'  출력 
		
		        url = urllib.request.Request( list_url, request_header )
		        res = urllib.request.urlopen(url).read().decode("utf-8")
		        #print (res)  
		        
		        soup=BeautifulSoup(res, "html.parser")
		        soup2 = soup.find_all('li', class_="pclist_list_tit42")
		        for i in soup2:
		            print(i.find('a')["href"])
		
		
		fetch_list_url() 


문제 401. 20181129905727  <----- 이부분만 추출하시오 !

	import  urllib.request
	from  bs4 import  BeautifulSoup
	import  os
	import  re
	
	def  fetch_list_url():
	    for  j  in  range(1,10):
	        list_url ="http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
	        request_header = urllib.parse.urlencode({"page": j})
	        # print(request_header) page = 1, page=2 ... 가 출력됨 
	
	        request_header = request_header.encode("utf-8")
	        # page=1 을 컴퓨터가 이해할수 있는 이진 코드로 변환 
	        # print (request_header)  #   b'page=1'  출력 
	
	        url = urllib.request.Request( list_url, request_header )
	        res = urllib.request.urlopen(url).read().decode("utf-8")
	        #print (res)  
	        
	        soup=BeautifulSoup(res, "html.parser")
	        soup2 = soup.find_all('li', class_="pclist_list_tit42")
	        for i in soup2:
	            soup3 = re.sub('[^0-9]', '', i.find('a')["href"])
	            # soup3 = re.search('[0-9]{14}', i.find('a')["href"]) 로 해도 됨
	            print(soup3)
	
	
	fetch_list_url() 



문제 402. params라는 비어있는 리스트변수에 위의 data들을 append 시키시오 !

	import  urllib.request
	from  bs4 import  BeautifulSoup
	import  os
	import  re
	
	def  fetch_list_url():
	    params = []
	    for  j  in  range(1,10):
	        list_url ="http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
	        request_header = urllib.parse.urlencode({"page": j})
	        # print(request_header) page = 1, page=2 ... 가 출력됨 
	
	        request_header = request_header.encode("utf-8")
	        # page=1 을 컴퓨터가 이해할수 있는 이진 코드로 변환 
	        # print (request_header)  #   b'page=1'  출력 
	
	        url = urllib.request.Request( list_url, request_header )
	        res = urllib.request.urlopen(url).read().decode("utf-8")
	        #print (res)  
	        
	        soup=BeautifulSoup(res, "html.parser")
	        soup2 = soup.find_all('li', class_="pclist_list_tit42")
	        
	        for i in soup2:
	            soup3 = re.sub('[^0-9]', '', i.find('a')["href"])
	            params.append(soup3)
	    print(params)
	
	
	fetch_list_url() 



문제 403. JavaScript:onView 함수에 위의 번호들이 어떻게 제공이 되어야 하는지 확인하시오 !

	 JavaScript:onView('20181129905727', '상세 게시판 글 url')
			↓
	 상세 게시판 글이 있는 html문서를 리턴해준다

	----------------------------------------------------
	   function onView (Seq) {
	            var Frm = document.mainForm;
	            Frm.RCEPT_NO.value = Seq;			# '20181129905727'
	            Frm.action = "/Shr/Shr01/Shr01_vie.jsp";	# '상세 게시판 글 url'
	            Frm.submit ();
	         }

		# RCEPT_NO : 20181129905727
	----------------------------------------------------



문제 404. RCEPT_NO : 20180820907144형태로 onView함수에 /Shr/Shr01/Shr01_vie.jsp와 같이 제공을 해서 상세 게시판
	  글의 html코드를 가져오는 fetch_list_url2()함수를 생성하시오 !

	import  urllib.request
	from  bs4 import  BeautifulSoup
	import  os
	import  re
	
	def  fetch_list_url():
	    params = []
	    for  j  in  range(1,5):
	        list_url ="http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
	        request_header = urllib.parse.urlencode({"page": j})
	        # print(request_header) page = 1, page=2 ... 가 출력됨 
	
	        request_header = request_header.encode("utf-8")
	        # page=1 을 컴퓨터가 이해할수 있는 이진 코드로 변환 
	        # print (request_header)  #   b'page=1'  출력 
	
	        url = urllib.request.Request( list_url, request_header )
	        res = urllib.request.urlopen(url).read().decode("utf-8")
	        #print (res)  
	        
	        soup=BeautifulSoup(res, "html.parser")
	        soup2 = soup.find_all('li', class_="pclist_list_tit42")
	        
	        for i in soup2:
	            soup3 = re.sub('[^0-9]', '', i.find('a')["href"])
	            params.append(soup3)
	    return params
	
	def  fetch_list_url2():
	    params2 = fetch_list_url() 
	 
	    for  i  in   params2:
	        detail_url = "http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_vie.jsp"
	        request_header = urllib.parse.urlencode({"RCEPT_NO": str(i) } )
	        request_header = request_header.encode("utf-8")
	        url = urllib.request.Request( detail_url, request_header)
	        res = urllib.request.urlopen(url).read().decode("utf-8")
	        soup = BeautifulSoup( res, "html.parser")
	        print (soup)  
	
	fetch_list_url2() 



문제 405. (점심시간 문제) 위의 코드를 이용해서 상세 게시판을 글들을 스크롤링 하는 코드를 완성시키시오 !

	import urllib.request  # 웹브라우저에서 html 문서를 얻어오기위해 통신하는 모듈
	from  bs4 import BeautifulSoup  # html 문서 검색 모듈
	import os
	import re
	
	def get_save_path():
	    save_path = input("Enter the file name and file location :" )
	    save_path = save_path.replace("\\", "/")
	    if not os.path.isdir(os.path.split(save_path)[0]):
	        os.mkdir(os.path.split(save_path)[0])
	    return save_path
	
	def fetch_list_url():
	    params = []
	    for j in range(1, 30):
	        list_url = "http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_lis.jsp"
	
	        request_header = urllib.parse.urlencode({"page": j})
	        # print (request_header) # 결과 page=1, page=2 ..
	
	        request_header = request_header.encode("utf-8")
	        # print (request_header) # b'page=29'
	
	        url = urllib.request.Request(list_url, request_header)
	        # print (url) # <urllib.request.Request object at 0x00000000021FA2E8>
	
	        res = urllib.request.urlopen(url).read().decode("utf-8")
	
	        soup = BeautifulSoup(res, "html.parser")
	        soup2 = soup.find_all("li", class_="pclist_list_tit42")
	        for soup3 in soup2:
	            soup4 = soup3.find("a")["href"]
	            params.append(re.search("[0-9]{14}", soup4).group())
	
	
	    return params
	
	
	def fetch_list_url2():
	
	    params2 = fetch_list_url()
	
	    f = open("c:\\result.txt" , 'w', encoding ="utf-8")
	
	    for i in params2:
	
	        detail_url = "http://eungdapso.seoul.go.kr/Shr/Shr01/Shr01_vie.jsp"
	
	        request_header = urllib.parse.urlencode({"RCEPT_NO": str(i) })
	        request_header = request_header.encode("utf-8")
	
	        url = urllib.request.Request(detail_url, request_header)
	        res = urllib.request.urlopen(url).read().decode("utf-8")
	        soup = BeautifulSoup(res, "html.parser")
	        soup2 = soup.find("div", class_="form_table")
	
	        tables = soup2.find_all("table")
	        table0   = tables[0].find_all("td")
	        table1   = tables[1].find("div",class_="table_inner_desc")
	        table2   = tables[2].find("div",class_="table_inner_desc")
	
	        date  = table0[1].get_text()
	        title = table0[0].get_text()
	        question = table1.get_text(strip=True)
	        answer   = table2.get_text(strip=True)
	
	        f.write("==" * 30 + "\n")
	        f.write(title + "\n")
	        f.write(date + "\n")
	        f.write(question + "\n")
	        f.write(answer + "\n")
	        f.write("==" * 30 + "\n")
	
	    f.close()
	    
	fetch_list_url2()
	

문제 406. 위의 결과를 워드클라우드로 출력하시오 !

	import Text_mining
	tm = Text_mining.Text_mining()
	tm.word_cloud()













■ 173. ~ 177 파이썬으로 게임 프로그램 개발

	※ 머신러닝 이란 ? "컴퓨터가 스스로 학습하는 것"

	※ 머신러닝의 종류 3가지 ?
		1. 지도학습 : 라벨(정답)이 있는 데이터를 학습하는 것
		2. 비지도 학습 : 라벨(정답)이 없는 데이터를 학습하는 것
		3. 강화 학습 : 상과 벌을 통해서 데이터를 만들어 내며 학습하는 방법

		   알파고 --> 머신러닝이 붐을 일으켰다.
		     ↓
		  강화학습

-----------------------------------------------------------------------------------------------
from tkinter import *
import random
import time

class Ball:

    def __init__(self, canvas, paddle, color):
        self.canvas = canvas
        self.paddle = paddle
        self.id = canvas.create_oval(10, 10, 25, 25, fill=color) #공 크기 및 색깔
        self.canvas.move(self.id, 245, 100) #공을 캔버스 중앙으로 이동
        starts = [-3, -2, -1, 1, 2, 3]  # 공의 속도를 랜덤으로 구성하기 위해 준비한 리스트
        random.shuffle(starts)  # starts 리스트 중에 숫자를 랜덤으로 골라서 
        self.x = starts[0] # 처음 공이 패들에서 움직일때 왼쪽으로 올라갈지 오른쪽으로 올라갈지 랜덤으로 결정되는 부분
        self.y = -3 # 처음 공이 패들에서 움직일때 위로 올라가는 속도 
        self.canvas_height = self.canvas.winfo_height() #캔버스의 현재 높이를 반환한다.(공이 화면에서 사라지지 않기위해)
        self.canvas_width = self.canvas.winfo_width() #캔버스의 현재 넓이를 반환한다.(공이 화면에서 사라지지 않기위해)
        self.hit_bottom = False

    def hit_paddle(self,pos):  # 패들에 공이 튀기게 하는 함수 
        paddle_pos = self.canvas.coords(self.paddle.id)
        if pos[2] >= paddle_pos[0] and pos[0] <= paddle_pos[2]:   # 공이 패들이 좌우로 겹친다.
            if pos[3] >= paddle_pos[1] and pos[1] <= paddle_pos[3]: # 공이 패들이 위아래로 겹친다. 
                return True
        return False

    def draw(self):
        self.canvas.move(self.id, self.x, self.y) #공을 움직이게 하는 부분
        #공이 화면 밖으로 나가지 않게 해준다
        pos = self.canvas.coords(self.id)  # 볼의 현재 좌표를 출력해준다. 공 좌표( 서쪽(0) , 남쪽(1) , 동쪽(2), 북쪽(3) )
                                                # [ 255,29,270,44] 
        if pos[1] <= 0:  # 공의 남쪽이 가리키는 좌표가 0보다 작아진다면 공이 위쪽 화면 밖으로 나가버리므로
            self.y = 3   # 공을 아래로 떨어뜨린다. (공이 위로 올라갈수로 y 의 값이 작아지므로 아래로 내리려면 다시 양수로)
        if pos[3] >= self.canvas_height: #공의 북쪽이 가리키는 좌표가 캔버스의 높이보다 더 크다면 화면 아래로 나가버려서
            self.y = -3 #공을 위로 올린다. (공이 아래로 내려갈수록 y 값이 커지므로 공을 위로 올릴려면 다시 음수로)
        if pos[0] <= 0:  # 공의 서쪽이 가리키는 좌표가 0보다 작으면 공이 화면 왼쪽으로 나가버리므로 
            self.x = 3  # 공을 오른쪽으로 돌린다.
        if pos[2] >= self.canvas_width: #공의 동쪽이 가리키는 좌표가 공의 넓이보다 크다면 공이 화면 오른쪽으로 나가버림
            self.x = -3 #공을 왼쪽으로 돌린다. 
        if self.hit_paddle(pos) == True: #패들 판에 부딪히면 위로 튕겨올라가게
            self.y = -3   # 공을 위로 올린다.

class Paddle:
    def __init__(self,canvas,color):
        self.canvas = canvas
        self.id = canvas.create_rectangle(0,0,100,10,fill=color) # 패들의 높이와 넓이 그리고 색깔
        self.canvas.move(self.id, 200, 300) # 패들 사각형을 200,300 에 위치 
        self.x = 0 #패들이 처음 시작할때 움직이지 않게 0으로 설정
        self.canvas_width = self.canvas.winfo_width() #캔버스의 넓이를 반환한다. 캔버스 밖으로 패들이 나가지 않도록
        self.canvas.bind_all('<KeyPress-Left>',self.turn_left)  # 왼쪽 화살표 키를 '<KeyPress-Left>'  라는 이름로 바인딩
        self.canvas.bind_all('<KeyPress-Right>',self.turn_right) # 오른쪽도 마찬가지로 바인딩한다.

    def draw(self): 
        self.canvas.move(self.id, self.x, 0) #시작할때 패들이 위아래로 움직이지 않도록 0 으로 설정
        pos = self.canvas.coords(self.id)
        print(pos)
        if pos[0] <= 0:  #공의 서쪽이 가리키는 좌표가 0보다 작으면 공이 화면 왼쪽으로 나가버리므로 
            self.x = 0 # 패들을 멈춰버린다. 
        elif pos[2] >= self.canvas_width: #공의 동쪽이 캔버스의 넓이 보다 크면 공이 화면 오른쪽으로 나가버리므로 
            self.x = 0 # 패들을 멈춰버린다

#패들이 화면의 끝에 부딪히면 공처럼 튕기는게 아니라 움직임이 멈춰야한다.
#그래서 왼쪽 x 좌표(pos[0]) 가 0 과 같거나 작으면 self.x = 0 처럼 x 변수에 0 을
#설정한다.  같은 방법으로 오른쪽 x 좌표(pos[2]) 가 캔버스의 폭과 같거나 크면 
#self.x = 0 처럼 변수에 0 을 설정한다. 

    def turn_left(self,evt):  # 패들의 방향을 전환하는 함수 
        self.x = -3

    def turn_right(self,evt):
        self.x = 3

tk = Tk()       # tk 를 인스턴스화 한다.
tk.title("Game")  # tk 객체의 title 메소드(함수)로 게임창에 제목을 부여한다.
tk.resizable(0, 0) # 게임창의 크기는 가로나 세로로 변경될수 없다라고 말하는것이다.
tk.wm_attributes("-topmost", 1)  #다른 모든 창들 앞에 캔버스를 가진 창이 위치할것을 tkinter 에게 알려준다. 

canvas = Canvas(tk, width=500, height=400, bd=0, highlightthickness=0)
# bg=0,highlightthickness=0 은 캔버스 외곽에 둘러싼 
# 외곽선이 없도록 하는것이다. (게임화면이 좀더 좋게)

canvas.pack() # 앞의 코드에서 전달된 폭과 높이는 매개변수에 따라 크기를 맞추라고 캔버스에에 말해준다.      
tk.update()  # tkinter 에게 게임에서의 애니메이션을 위해 자신을 초기화하라고 알려주는것이다.
paddle = Paddle(canvas,'blue')
ball = Ball(canvas, paddle, 'red')
start = False
#공을 약간 움직이고 새로운 위치로 화면을 다시 그리며, 잠깐 잠들었다가 다시 시작해 ! "
while 1:
    if ball.hit_bottom == False:
        ball.draw()
        paddle.draw()
    tk.update_idletasks()  # 우리가 창을 닫으라고 할때까지 계속해서 tkinter 에게 화면을 그려라 !
    tk.update()  # tkinter 에게 게임에서의 애니메이션을 위해 자신을 초기화하라고 알려주는것이다.
    time.sleep(0.01) # 무한 루프중에 100분의 1초마다 잠들어라 
-------------------------------------------------------------------------------------------------------


★ 파이썬으로 ping pong게임 구현

	"tkinter 라는 모듈을 사용해서 구현"

	* ping pong 게임을 하려면 필요한게 무엇인가 ?

		1. 캔버스(canvas) ---> 게임 바탕
		2. 공(ball) 클래스
			- init 함수 : 공의 색깔과 크기를 설정, 캔버스에서의 공의 시작위치를 설정
			- 공을 움직이게 하는 함수 : 공이 캔버스 밖으로 안나가게 하는 코드 구현
			- 패들에 공이 부딪히면 공이 튀기게 하는 함수
		3. 패들(paddle) 클래스
			- init 함수 : 패들의 색깔과 크기를 설정.
				      캔버스에서의 패들의 시작위치를 설정
			- 패들을 움직이게 하는 함수 :
				패들이 캔버스 밖으로 안나가게 하는 코드 구현
			- 왼쪽으로 패들을 움직이게 하는 함수
			- 오른쪽으로 패들을 움직이게 하는 함수



문제 407. 캔버스를 그리시오 !

	from tkinter import * 
	import random
	import time
	
	tk = Tk()      			# 1. tk 를 인스턴스화 한다.
	tk.title("Game")  		# 2. tk 객체의 title 메소드(함수)로 게임창에 제목을 부여한다.
	tk.resizable(0, 0) 		# 3. 게임창의 크기는 가로나 세로로 변경될수 없다라고 말하는것이다. 
	tk.wm_attributes("-topmost", 1) # 4. 다른 모든 창들 앞에 캔버스를 가진 창이 위치할것을 tkinter에게 알려준다
	canvas = Canvas(tk, width=500, height=500, bd=0, highlightthickness=0) 
					# bg=0,highlightthickness=0 은 캔버스 외곽에 둘러싼 
					# 외곽선이 없도록 하는것이다. (게임화면이 좀더 좋게)
	canvas.pack()       		# 앞의 코드에서 전달된 폭과 높이는 매개변수에 따라 크기를 맞추라고 캔버스에						# 에 말준다.

	tk.update()   			# tkinter 에게 게임에서의 애니메이션을 위해 자신을 초기화하라고 알려주는것						# 이다.
					# 창이 바로 꺼지는것을 막을려면 ?   mainloop() 라 불리는 애니메이션 루프를 						# 추가해야 한다.
	tk.mainloop()
 


문제 408. 캔버스위에 ball을 올려놓기 위해 ball클래스를 생성하시오 !

	from tkinter import * 
	import random
	import time
	
	class Ball:
	    def __init__(self, canvas, color):
	        self.canvas = canvas
	        self.id = canvas.create_oval(10, 10, 25, 25, fill=color) #공 좌표 및 색깔(oval : object 형태 타입)
	                               #        ↑   ↑  ↑    ↑
	      #좌측상단  구석에서 시작하는  x  y   우측 상단 구석에서 시작하는 x y
	        self.canvas.move(self.id, 245, 100) #공을 캔버스 중앙으로 이동
	    def draw(self):
	        pass
	    
	tk = Tk()     
	tk.title("Game")
	tk.resizable(0, 0) 
	tk.wm_attributes("-topmost", 1) 
	canvas = Canvas(tk, width=500, height=500, bd=0, highlightthickness=0) 
	
	canvas.pack()                                                                        
	tk.update()   
	
	ball = Ball(canvas,'red')
	while 1:
	    tk.update_idletasks()   # 우리가 창을 닫으라고 할때까지 계속해서 tkinter 에게 화면을 그리고 
	    tk.update() 
	    time.sleep(0.01)



문제 409. 캔버스를 검정색으로 하고 공을 하얀색으로 변경하시오 !

	from tkinter import * 
	import random
	import time
	
	class Ball:
	    def __init__(self, canvas, color):
	        self.canvas = canvas
	        self.id = canvas.create_oval(10, 10, 25, 25, fill=color) #공 좌표 및 색깔(oval : object 형태 타입)
	                               #        ↑   ↑  ↑    ↑
	      #좌측상단  구석에서 시작하는  x  y   우측 상단 구석에서 시작하는 x y
	        self.canvas.move(self.id, 245, 100) #공을 캔버스 중앙으로 이동
	    def draw(self):
	        pass
	    
	tk = Tk()     
	tk.title("Game")
	tk.resizable(0, 0) 
	tk.wm_attributes("-topmost", 1) 
	canvas = Canvas(tk, width=500, height=500, bd=0, highlightthickness=0) 
	
	canvas.configure(background='black')
	canvas.pack()                                                                        
	tk.update()   
	
	ball = Ball(canvas,'white')
	while 1:
	    tk.update_idletasks()   # 우리가 창을 닫으라고 할때까지 계속해서 tkinter 에게 화면을 그리고 
	    tk.update() 
	    time.sleep(0.01)    # 100분의 1초마다 잠들어라 ! 



문제 410. 캔버스의 공의 첫 시작위치가 천정 위가 되게 하시오 !

	from tkinter import * 
	import random
	import time
	
	class Ball:
	    def __init__(self, canvas, color):
	        self.canvas = canvas
	        self.id = canvas.create_oval(10, 10, 25, 25, fill=color) #공 좌표 및 색깔(oval : object 형태 타입)
	                               #        ↑   ↑  ↑    ↑
	      #좌측상단  구석에서 시작하는  x  y   우측 상단 구석에서 시작하는 x y
	        self.canvas.move(self.id, 245, 0) #공을 캔버스 중앙으로 이동
	    def draw(self):
	        pass
	    
	tk = Tk()     
	tk.title("Game")
	tk.resizable(0, 0) 
	tk.wm_attributes("-topmost", 1) 
	canvas = Canvas(tk, width=500, height=500, bd=0, highlightthickness=0) 
	
	canvas.configure(background='black')
	canvas.pack()                                                                        
	tk.update()   
	
	ball = Ball(canvas,'white')
	while 1:
	    tk.update_idletasks()   # 우리가 창을 닫으라고 할때까지 계속해서 tkinter 에게 화면을 그리고 
	    tk.update() 
	    time.sleep(0.01)    # 100분의 1초마다 잠들어라 ! 




문제 411. 공이 키보드의 방향키로 움직어지게 하려면?

관련코드 :  self.canvas.move( self.id, self.x,  self.y) 
                                ↓       ↓        ↓
                                공    공의 x 방향  공의 y 방향
                                       (좌, 우)     (위 아래)

                키보드 방향키와 공을 움직이는 함수를 매칭시켜준다.

 self.canvas.bind_all('<KeyPress-Left>', self.turn_left)
 # 키보드 방향키 <- 를 누르면 turn_left 함수가 실행되게해라 !

 self.canvas.bind_all('<KeyPress-Right>', self.turn_right)
 # 키보드 방향키 -> 를 누르면 turn_right 함수가 실행되게해라 !


 def  turn_left(self, evt ):
     self.x = -9

 def  turn_right(self, evt):
     self.y = 9


	from tkinter import * 
	import random
	import time
	
	class Ball:
	    def __init__(self, canvas, color):
	        self.canvas = canvas
	        self.id = canvas.create_oval(10, 10, 25, 25, fill=color)
	        self.x=0
	        self.y=0
	        self.canvas.move(self.id, 245, 0)
	        self.canvas.bind_all('<KeyPress-Left>',self.turn_left)
	        self.canvas.bind_all('<KeyPress-Right>',self.turn_right)
	        self.canvas.bind_all('<KeyPress-Up>',self.turn_up)
	        self.canvas.bind_all('<KeyPress-Down>',self.turn_down)
	
	    def draw(self):
	        self.canvas.move( self.id, self.x,  self.y)
	        
	    def turn_left(self,evt):
	        self.x = -3
	
	    def turn_right(self,evt):
	        self.x = 3
	
	    def turn_up(self,evt):
	        self.y = -3
        
	    def turn_down(self,evt):
	        self.y = 3
	        pass
	
	    
	tk = Tk()     
	tk.title("Game")
	tk.resizable(0, 0) 
	tk.wm_attributes("-topmost", 1) 
	canvas = Canvas(tk, width=500, height=500, bd=0, highlightthickness=0) 
	
	canvas.configure(background='black')
	canvas.pack()                                                                        
	tk.update()   
	
	ball = Ball(canvas,'white')
	while 1:
	    ball.draw()
	    tk.update_idletasks()   # 우리가 창을 닫으라고 할때까지 계속해서 tkinter 에게 화면을 그리고 
	    tk.update() 
	    time.sleep(0.01)    # 100분의 1초마다 잠들어라 ! 



문제 412. (오늘의 마지막 문제) 공이 아래로 떨어졌을 때 게임이 끝나는게 아니라 공이 다시  위로 올라가게 하시오 !

	from tkinter import *
	import random
	import time
	
	class Ball:
	    def __init__(self, canvas, paddle, color):
	        self.canvas = canvas
	        self.paddle = paddle
	        self.id = canvas.create_oval(10, 10, 25, 25, fill=color)
	        canvas.configure(background='black') # 캔버스의 색깔을 검정색으로 하겠다.
	        self.canvas.move(self.id, 245, 100)
	        starts = [-3, -2, -1, 1, 2, 3]
	        random.shuffle(starts)
	        self.x = starts[0]
	        self.y = -3
	        self.canvas_height = self.canvas.winfo_height()
	        self.canvas_width = self.canvas.winfo_width()
	        self.hit_bottom = False # 바닥에 닿으면 게임 끝나는 코드를
	                                # 구현하기 위해서 쓰는 변수
	
	    def draw(self):
	        self.canvas.move(self.id, self.x, self.y)
	        pos = self.canvas.coords(self.id)
	        if pos[1] <= 0:
	            self.y = 3
	        if pos[3] >= self.canvas_height:
	            self.y = -3
	        if pos[0] <= 0:
	            self.x = 3
	        if pos[2] >= self.canvas_width:
	            self.x = -3
	        if self.hit_paddle(pos) == True:
	            self.y = -3
	
	    def hit_paddle(self,pos):
	        paddle_pos = self.canvas.coords(self.paddle.id)
	        if pos[2] >= paddle_pos[0] and pos[0] <= paddle_pos[2]:
	            if pos[3] >= paddle_pos[1] and pos[1] <= paddle_pos[3]:
	                return True
	        return False
	
	class Paddle:
	    def __init__(self,canvas,color):
	        self.canvas = canvas
	        self.id = canvas.create_rectangle(0,0,100,10,fill=color)
	        self.canvas.move(self.id, 200, 400)
	        self.x = 0
	        self.y = 0
	        self.canvas_width = self.canvas.winfo_width()
	        self.canvas.bind_all('<KeyPress-Left>',self.turn_left)
	        self.canvas.bind_all('<KeyPress-Right>',self.turn_right)
	        self.canvas.bind_all('<KeyPress-Up>',self.turn_up)
	        self.canvas.bind_all('<KeyPress-Down>',self.turn_down)
	
	    def draw(self):
	        self.canvas.move(self.id, self.x, self.y)
	        pos = self.canvas.coords(self.id)
	        if pos[0] <= 0:
	            self.x = 0
	        elif pos[2] >= self.canvas_width:
	            self.x = 0
	
	    def turn_left(self,evt):
	        self.x = -9
	        
	    def turn_right(self,evt):
	        self.x = 9
	
	    def turn_up(self,evt):
	        self.y = -9
	
	    def turn_down(self,evt):
	        self.y = 9
	
	tk = Tk()
	tk.title("Game")
	tk.resizable(0, 0)
	tk.wm_attributes("-topmost", 1)
	canvas = Canvas(tk, width=600, height=500, bd=0, highlightthickness=0)
	canvas.pack()
	tk.update()
	paddle = Paddle(canvas,'white')
	ball = Ball(canvas, paddle, 'white')
	
	while 1:
	    ball.draw()
	    paddle.draw()
	    tk.update_idletasks()
	    tk.update()
	    time.sleep(0.02)





















