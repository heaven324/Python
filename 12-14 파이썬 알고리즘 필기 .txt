문제 414. (탐욕 알고리즘) 탐욕 알고리즘을 이용하여 금액과 화폐가 주어졌을 때 가장 적은 화폐로 지불하시오 !

"탐욕 알고리즘이 어떤 알고리즘이냐면, 매 순간마다 최선의 선택하는것 입니다. 
 즉, 선택할때마다 가장 좋다고 생각되는 것을 선택해나가며 
 최종적인 해답을 구하는 알고리즘 입니다. 
 이 알고리즘을 설계할 때 유의할 점은 전체를 고려하는게 아니라 문제를 부분적으로 나누어, 나누어진 문제에 대한 최적의 
 해답을 구하므로 전체적인 최적의 해가 될 수 있는 경우가 존재합니다. "
  최단 거리 알고리즘 구현하기 위해서 필요한 알고리즘이
                "탐욕(greedy) 알고리즘 "


액수 입력: 362

화폐단위를 입력하세요 : 1 50 100

결과 :
100원 :3개
50원 : 1개
1원 : 12개 


참고 스크립트 :

money = int(input('액수입력 : '))
cash_type = [int(x) for x in input('화폐단위를 입력하세요 : ').split(' ')]
res = coinGreedy(money,cash_type)
for key in res:
    print('{0}원 : {1}개'.format(key,res[key]))


	답 : 

		def greedy():
		    money = int(input('액수입력 : '))
		    cash_type = [int(x) for x in input('화폐단위를 입력하세요 : ').split(' ')]
		    cash_type.sort(reverse = True)
		    for cash in cash_type:
		        x = int((money - (money%cash))/cash)
		        money = money - x*cash
		        print('%d원 : %d개'%(cash, x))
	
		greedy()







문제 415. (탐욕 알고리즘) 아래와 같이 결과가 출력되게 하시오 !
	  동전의 개수를 최소로 나오게 출력






# 카카오 알고리즘 문제
#문제 43. 오늘 마지막 문제로 검사 받아야할 알고리즘 문제 13번 (카카오 2017년 3번 문제 : LRU알고리즘)
# city = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "Jeju", "Pangyo", "Seoul", "NewYork", "LA"] # cache 3 50
# city = ["Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul"] # cache 3 21
# city = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"] # cache 2 60
# city = ["Jeju","Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"] # cache 5 52
# city = ["Jeju","Pangyo", "NewYork", "newyork"] # cache 2 16
# city = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA"] # cache 0 25
city = ['a','b','c','a','e','d','a'] # 3
def LRU(city):
    cache_size = int(input('캐시 사이즈를 입력하세요 !'))
    cache_hit = 1
    cache_miss = 5
    cache = []
    time = 0
    for i in city:
        i = i.lower()
        if cache_size == 0:
            time = len(city)*cache_miss
            break
        elif len(cache) < cache_size:
            cache.append(i)
            time += cache_miss
        else: 
            if cache.count(i) >= 1:
                time += cache_hit
                pass
            else:
                del cache[0]
                cache.append(i)
                time += cache_miss
    return time
print(LRU(city))








# 카카오 알고리즘 문제
#문제 43. 오늘 마지막 문제로 검사 받아야할 알고리즘 문제 13번 (카카오 2017년 3번 문제 : LRU알고리즘)
# city = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "Jeju", "Pangyo", "Seoul", "NewYork", "LA"] # cache 3 50
# city = ["Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul"] # cache 3 21
# city = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"] # cache 2 60
# city = ["Jeju","Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"] # cache 5 52
# city = ["Jeju","Pangyo", "NewYork", "newyork"] # cache 2 16
# city = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA"] # cache 0 25

# 원래의 결과와 달라지는 예제 ! 원래의 결과 31
city = ['a','b','c','a','e','d','a'] # 3
def LRU(city):
    cache_size = int(input('캐시 사이즈를 입력하세요 !'))
    cache_hit = 1
    cache_miss = 5
    cache = []
    time = 0
    for i in city:
        i = i.lower()
        if cache_size == 0:
            time = len(city)*cache_miss
            break
        elif len(cache) < cache_size:
            cache.append(i)
            time += cache_miss
        else: 
            if cache.count(i) >= 1:
                time += cache_hit
                cache.remove(i)
                cache.append(i)
            else:
                del cache[0]
                cache.append(i)
                time += cache_miss
    return time
print(LRU(city))



def solution(cache_size, city):
    cache_hit = 1
    cache_miss = 5
    time = 0
    if cache_size == 0:
        time = len(city)*cache_miss
        return time
    cache = []
    for i in city:
        i = i.lower()
        if cache.count(i) >= 1:
            time += cache_hit
            cache.remove(i)
            cache.append(i)
            pass
        else:
            if cache == []:
                pass
            else:
                del cache[0]
            cache.append(i)
            time += cache_miss
            pass
    return time




# 카카오 알고리즘 문제

#**********************cpu 적재방식 구조를 따라 만든 코드**************************

#문제 43. 오늘 마지막 문제로 검사 받아야할 알고리즘 문제 13번 (카카오 2017년 3번 문제 : LRU알고리즘)
city1 = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "Jeju", "Pangyo", "Seoul", "NewYork", "LA"] # cache 3 50
city2 = ["Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul", "Jeju", "Pangyo", "Seoul"] # cache 3 21
city3 = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"] # cache 2 60
city4 = ["Jeju","Pangyo", "Seoul", "NewYork", "LA", "SanFrancisco", "Seoul", "Rome", "Paris", "Jeju", "NewYork", "Rome"] # cache 5 52
city5 = ["Jeju","Pangyo", "NewYork", "newyork"] # cache 2 16
city6 = ["Jeju", "Pangyo", "Seoul", "NewYork", "LA"] # cache 0 25

# 원래의 결과와 달라지는 예제 ! 원래의 결과 31, 답 : 27
city7 = ['a','b','c','a','e','d','a'] # 3
def LRU(city):
    cache_size = int(input('캐시 사이즈를 입력하세요 !'))
    cache_hit = 1
    cache_miss = 5
    cache = {}
    time = 0
    cnt = 0
    for i in city:
#         print(i)
        cnt += 1
#         print(cnt)
        i = i.lower()
        if cache_size == 0:
            time = len(city)*cache_miss
            break
        elif len(cache) < cache_size:
            cache[i] = cnt
#             print(cache.items(), '현재 time', time)
            time += cache_miss
        else: 
            if i in cache:
                time += cache_hit
                cache[i] = cnt
#                 print('있어서 ',cache.items(), '현재 time', time)
            else:
                del cache[min(cache.items(), key=lambda x: x[1])[0]]
                cache[i] = cnt
                time += cache_miss
#                 print('없어서 ',cache.items(), '현재 time', time)
#         print('============================')
    return time
# print(LRU(city))
print('결과 = ', LRU(city1))
print('결과 = ', LRU(city2))
print('결과 = ', LRU(city3))
print('결과 = ', LRU(city4))
print('결과 = ', LRU(city5))
print('결과 = ', LRU(city6))
print('결과 = ', LRU(city7))










#문제 83. (카카오 비밀지도 문제)

n = 5
arr1 = [9, 20, 28, 18, 11]
arr2 = [30, 1, 21, 17, 28]
    
# n = 6
# arr1 = [46, 33, 33, 22, 31, 50]
# arr2 = [27, 56, 19, 14, 14, 10]

result = []
for i in range(n):
    result_str = bin(arr1[i]|arr2[i]+2**n)[3:]
    result_str1 = result_str.replace('1', '#')
    result_str2 = result_str1.replace('0', ' ')
    result.append(result_str2)
print(result)





