■ 이번주 일정

	월	화	수	목	금	토
				       휴일    SQLD


이번주 목표 : 알고리즘 문제 (EBS)



■ 41. 지역변수와 전역변수 이해하기 (global)

	"변수는 자신이 생성된 범위 (코드블럭) 안에서만 유효하다. 함수 안에서 만든 변수는 함수 안에서만
	 살아있다가 함수 코드의 실행이 종료되면 그 생명을 다한다."

	이것을 지역변수라고 한다.

	이와는 반대로 함수 외부에서 만든 변수는 프로그램이 살아있는 동안에 함께 살아있다가 프로그램이 종료
	되면 같이 소멸 된다.

	이렇게 프로그램 전체를 유효범위로 가지는 변수를 전역변수 라고 한다.

	예 : 
		param = 10
		strdata = '전역변수'
		
		def func1():
		    strdata = '지역변수'
		    print(strdata)
		    
		print(func1())

		지역변수

	* 지역변수를 설명하는 코드
		param = 10

		def func2(param):
		    param = 1
		    
		func2(param)
		
		print(param)		# 무엇이 출력될까?

		10
			"함수 안에서 만든 변수는 함수 안에서만 살아있다가 함수 코드의 실행이 종료되면 그
			 생명을 다한다."

			이 변수를 지역변수라고 한다.

	* 전역변수를 설명하는 코드

		param = 10
	
		def func3():
		    global param
		    param = 50	
	    	
		func3()
		
		print(param)

			"전역변수는 함수내부 뿐만 아니라 함수 외부에서도 사용되는 프로그램 변수이다."

			 * 프로그램이란 ? 여러가지 기능(함수)를 모아놓은 코드

	※ 어떤 변수를 전역변수로 사용해야 하는가 ?

	프로그램 전체에서 공통적으로 사용되고 잘 변하지 않는 데이터는 전역변수로 사용한다.

	예 :
		pi = 3.141592653589793

		함수1(기능 : 원의 넓이를 구하는 함수):
		global pi
		print(pi * 반지름 * 반지름)

		함수1(기능: 두개의 원의 넓이를 구하는 함수):
		global pi
		print(pi.......)




문제 162. 위의 예제를 코드로 구현하시오 !

	print( cycle_func1(5) )		# 한개의 원의 넓이 출력
	78.53981633974483

	print( cycle_func2(5))		# 두개의 원의 넓이 출력
	157.07963267948966

		pi = 3.141592653589793
		
		def cycle_func1(radius):
		    global pi
		    return pi*radius*radius
		
		print( cycle_func1(5) )
		
		def cycle_func2(radius):
		    global pi
		    return pi*radius*radius*2
		
		print( cycle_func2(5))



■ 42. 함수 리턴값 이해하기(return)

	"모든 함수는 이름을 갖고 있다. 이 이름을 불러주면 파이썬은 그 이름 아래 정의되어 있는 코드를
	 실행한다.

	이때 함수를 부르는 행위를 호출이라고 하고 함수를 부르는 코드를 호출자라고 한다.

	함수가 호출자에게 결과를 들려주는 것을 반환(return)이라고 한다."

	예제 : 
		def initcap(val):
		    return(val[0].upper() + val[1:].lower() )

		print(initcap('smith'))

	예제 :
		param = 10
		
		def func3():
		    global param
		    param = 50
		    
		func3()
		print(param)		# 무엇이 출력될까?





print(abs(-9))		# 절대값 출력하는 함수
			  (무조건 양수로 출력하는 함수)

문제 163. abs 쓰지 말고 if 문으로 my_abs라는 함수를 생성하시오 !(무조건 양수로 출력하는 함수)

		print(my_abs(9))
		9
		print(my_abs(-9))
		9

		def my_abs(num):
		    if num < 0:
		        num = -num
		    return num








■ 43. 파이썬 모듈 이해하기

	" 파이썬에서는 각각의 소스 파일을 일컬어 모듈이라고 한다."

	이미 만들어져 있고 안정성이 검증된 함수들을 성격에 맞게 하나의 파일로 묶어놓은 것을 모듈이라고 한다.

	외부에 모듈에 있는 함수를 사용하려면 이 모듈을 먼저 우리 코드로 가져와서 자유롭게 사용할 수 있도록
	해야 하는데 이런 일을 파이썬에서는 모듈을 import 한다라고 한다.

	예제 : 
		import time
		print('5초간 프로그램을 정지합니다.')
		time.sleep(5)
		print('5초가 지났습니다.')


문제 164. 아래의 4개의 함수를 가지고  cal_test3.py라는 모듈을 생성하시오 !

	def plus(a, b):
	    return a+b
	
	def minus(a, b):
	    return a - b
	
	def multiply(a, b):
	    return a*b
	
	def divide(a, b):
	    return a/b

	cal_test3.py가 있는 위치에 다른 코드에서 cal_test3.py 를 호출해서 아래와 같이 코드를 실행해 
	보시오 ~

	import cal_test3 as c
	
	c.plus(10,20)





■ 44. 파이썬 패키지 이해하기

	"우리가 음악파일을 저장할때도 장르별로 폴더를 만들어서 별도로 저장하듯이 파이썬 모듈도 음악처럼
	갯수가 많아지면 폴더(모듈 꾸러미) 별로 관리를 해야 관리 편해지는데 이 폴더(디렉토리)가 패키지다."

	C:\Users\Administrator\.spyder-py3\my_loc

	__init__.py는 대개 비워두는 것이 보통인데 이 파일을 손대는 경우는 언제인가?

	답 : __all__ 변수를 조정할 때 손을 댄다.
		↓
	패키지로 부터 반입할 목록을 정의할 때 사용

	__init__.py를 열어서 아랴의 내용을 적으시오 

	__all__ = [ 'cal_test3', 'oracle_func' ]

	위와 같이 __init__ 에 __all__를 설정해놓으면 패키지의 모듈을 불러올 때 아래의 명령어가 가능해진다.

	from my_loc import *

	원래는 어떻게 해야 하냐면 ?

	from my_loc import cal_test3
	from my_loc import oracle_func



문제 166. (점심시간 문제) mean 이라는 함수를 생성 하시오 !
	  (가변 매개변수를 이용해서 숫자를 몇개 넣고 실행하던 상관없이 평균값이 구해지게 하시오 )

	print( mean( 7,9,2,5,4,9,8))
	6.285714285714286
	print( mean(7, 9, 2, 5, 4, 9, 8, 10, 12))
	7.333333333333333
	
	def mean(*num):
	    num_list = list(num)
	    result = 0
	    for i in num_list:
	        result += i
	    return result/len(num_list)
	
	print( mean( 7,9,2,5,4,9,8))







■ 45. 파이썬 모듈 임폴트 하기 ① ( import )

	설명 : import 문을 만나면 파이썬 모듈을 찾는 순서
		1. 파이썬 내장 모듈
		2. sys.path에 정의되어있는 디렉토리








■ 46. 파이썬 모듈 임폴트 이해하기 ② ( from ~ import )

	C:\Users\Administrator\.spyder-py3\my_loc(패키지)
					    ↓
					cal_test3.py 	(모듈)
					    ↓
					   plus 	(함수)
					   minus 	(함수)
					  multiply	(함수)
					  divide	(함수)

	C:\Users\Administrator\.spyder-py3\temp.py

	temp.py에서 cal_test3.py모듈 안의 plus함수를 사용하고 싶다면 ?

	import my_loc.cal_test3
	print(my_loc.cal_test3.plus(10,20))	# 너무 길어서 불편해!

		↓	(좀더 편하게 코딩)

	import my_loc.cal_test3 as mc
	print( mc.plus(10,20))			# 좀 나아졋네, 좀 더 줄여볼까??
	
		↓	(좀더 편하게 코딩)

	from my_loc.cal_test3 import plus	# 엥 아무것도 안붙여도 되네?
	print(plus(10,20))			  근데 plus만 쓸수가 있네
	
		↓	(좀더 편하게 코딩)

	from my_loc.cal_test3 import *
	print(plus(10,20))			# 이제 cal_test3함수들 다쓸 수 있다 !!
	print(minus(20,10))








■ 47. 파이썬 모듈 임폴트 이해하기 ③ ( import ~ as )

	예제 :

		import my_loc.cal_test3 as mc
		print( mc.plus(10,20))












■ 48. 파일 열고 닫기 ( open, close )

	예제 : 이미지 파일을 파이썬에서 여는 방법


	import PIL.Image as pilimg
	import numpy as np
	import matplotlib.pyplot as plt
	
	im = pilimg.open('c:\\lena.png')
	pix = np.array(im)
	
	plt.imshow(pix)







■ 49. 클래스 이해하기 (class)

	클래스 (자료형) -----> 객체

	클래스는 자료형이고 아직 객체가 되지 않았다.
		   ↓		  ↓
		붕어빵 틀	붕어빵

		차  설계도	  차
		총  설계도	  총
	     고릴라 설계도	고릴라


 * 클래스가 필요한 이유에 대한 실습

	▷ 계산기 함수 생성

	result = 0
	
	def adder(num):
	    global result
	    result = result + num
	    return result
	
	print( adder(3) )
	print( adder(4) )

	print( adder(2) )
	print( adder(5) )

	14가 나와버린다.

	결국 계산기가 하나 더 필요하다.
	adder 함수 하나만으로는 결과값을 따로 유지할 수 없다.

	result1 = 0
	result2 = 0
	
	def adder1(num):
	    global result1
	    result1 = result1 + num
	    return result1
	
	def adder2(num):
	    global result2
	    result2 = result2 + num
	    return result2
	
	print( adder1(3) )
	print( adder1(4) )
	
	print( adder2(2) )
	print( adder2(5) )

	계산기1 과 계산기2 를 가지고 계산을 했는데 하지만 계산기가 3개, 4개, 5개, 10개로 점점 더 많이
	필요해진다면 어떻게 해야 할 것인가?

	그 때마다 전역변수와 함수를 추가할 것인가?

	이 문제를 클래스가 간단하게 해결해 준다.

	class Calculator:           # 계산기 설계도(클래스)를 만든다.
	    def__init__(self):      # 계산기 초기화하는 함수 반드시 함수 이름 __init__
	        self.result = 0
	
	    def adder(self, num):        # 더하기 하는 함수
	        self.result += + num
	        return self.result1

	# 설계도(클래스)를 가지고 계산기 2개 생성

	cal1 = Calculator()
	cal2 = Calculator()	
	
	print(cal1.adder(3))
	print(cal1.adder(4))
	print(cal2.adder(2))
	print(cal2.adder(5))



문제 168. Calculator 클래스(계산기 설계도)에 빼기(minus), 곱하기(multiply), 나누기(divide) 함수 
	  3개를 추가하고 실행해보시오 !

	class Calculator:
	    def __init__(self):
	        self.result = 0
	
	    def adder(self, num):
	        self.result += num
	        return self.result
	    
	    def minus(self, num):
	        self.result -= num
	        return self.result
	
	    def multiply(self, num):
	        self.result *= num
	        return self.result
	
	    def divide(self, num):
	        self.result /= num
	        return self.result
	
	
	cal3 = Calculator()

	print(cal3.adder(3))
	print(cal3.minus(4))
	print(cal3.multiply(2))
	print(cal3.divide(5))



문제 169. 총 클래스를 생성하고 객체화 시키시오 !

	class Gun():
	    def __init__(self):					# 클래스가 실체화 될때 바로 작동
	        self.bullet = 0					# 하는 메소드
	        
	    def charge(self, num):				# 충전하는 기능
	        self.bullet = num
	        
	    def shoot(self, num):				# 총 쏘는 기능
	        for i in range(num):
	            if self.bullet > 0:
	                print('탕!')
	                self.bullet -= 1
	            elif self.bullet == 0:
	                print('총알이 없습니다')
	                break
	    
	    def print(self):					# 출력하는 기능
	        print(' {} 발 남았습니다.'.format(self.bullet))
	        
	# 총을 실체화 시킨다.
	gun1 = Gun()
	
	# 총알을 충전한다.
	gun1.charge(10)
	
	# 총알을 쏜다.
	gun1.shoot(3)
	
	# 몇발 남았는지 확인한다.
	gun1.print()

	탕!
	탕!
	탕!
	 7 발 남았습니다.



문제 170. 총알 충전할 때 몇발 충전 되었습니다. 라는 메세지가 출력되게 하시오 !

	class Gun:
	    def __init__(self):
	        self.bullet = 0
	        
	    def charge(self, num):
	        self.bullet = num
	        print('{}발 충전 되었습니다.'.format(self.bullet))
	        
	    def shoot(self, num):
	        for i in range(num):
	            if self.bullet > 0:
	                print('탕!')
	                self.bullet -= 1
	            elif self.bullet == 0:
	                print('총알이 없습니다')
	                break
	    
	    def print(self):
	        print(' {}발 남았습니다.'.format(self.bullet))
	        
	gun1 = Gun()
	gun1.charge(10)
	gun1.shoot(3)
	gun1.print()

	10발 충전 되었습니다.
	탕!
	탕!
	탕!
	 7발 남았습니다.


문제 170. 고릴라 클래스를 구현해서 고릴라 객체를 만드시오 ~

	기능 :  1. 소리지르는 기능 :  shout

			우와 ~~~~~~~
			소리를 지를 수 없습니다. <----- 바나나가 없으면

		2. 바나나 먹는 기능 : eat

		3. 바나나가 뱃속에 몇개 남았는지 프린트 하는 기능

	바나나를 10개 먹었으면 소리를 10번 지를 수 있다.

		class Monky:
		    def __init__(self):
		        self.banana = 0
		        
		    def eat(self, num):
		        self.banana = num
		        print('고릴라가 바나나 {}개를 먹었습니다.'.format(self.banana))
		        
		    def shout(self, num):
		        for i in range(num):
		            if self.banana > 0:
		                print('우와~~~~~~~~~')
		                self.banana -= 1
		                if self.banana == 0:
		                    print('소리를 지를 수 없습니다.')
		                    break
		    
		    def print(self):
		        print('고릴라 뱃속에 바나나가 {}개 남았습니다.'.format(self.banana))
		        
		monky = Monky()
		monky.eat(10)
		monky.shout(3)
	monky.print()



문제 171. 위의 고릴라의 기능중에 걷는 기능을 추가하시오 !
	  메소드의 이름은 walk라고 한다.

	print(go.walk(3))
	뚜벅 !
	뚜벅 !
	뚜벅 !

	바나나가 없으면 배가 고파 걸을 수 없습니다. 메세지 출력
	바나나가 없으면 배가고파 소리를 지를 수 없습니다.

	바나나를 10개를 먹었으면 10번 소리를 지를 수 있다.
	바나나를 10개를 먹었으면 10번 걸을 수 있다.
	바나나를 10개를 먹었으면 5번 소리지를 수 있고 5번 걸을 수 있다.

	class Monky:
	    def __init__(self):
	        self.banana = 0
	        
	    def eat(self, num):
	        self.banana = num
	        print('고릴라가 바나나 {}개를 먹었습니다.'.format(self.banana))
	        
	    def shout(self, num):
	        for i in range(num):
	            if self.banana > 0:
	                print('우와~~~~~~~~~')
	                self.banana -= 1
	                if self.banana == 0:
	                    print('바나나가 없으면 배가 고파 걸을 수 없습니다.')
	                    print('바나나가 없으면 배가고파 소리를 지를 수 없습니다.')
	                    break
	
	    def walk(self, num):
	        for i in range(num):
	            if self.banana > 0:
	                print('뚜벅 !')
	                self.banana -= 1
	                if self.banana == 0:
	                    print('바나나가 없으면 배가 고파 걸을 수 없습니다.')
	                    print('바나나가 없으면 배가고파 소리를 지를 수 없습니다.')
	                    break
	    
	    def print(self):
	        print('고릴라 뱃속에 바나나가 {}개 남았습니다.'.format(self.banana))
	        
	monky = Monky()
	monky.eat(10)
	monky.shout(3)
	monky.walk(7)
	monky.print()



문제 172. Card 클래스를 생성해서 카드를 발급하시오 !

	Movie_Card 클래스

		- 충전 기능 ( Charge )
		- 소비 기능 ( Consume )
			Consume(3000, '마트')
			Consume(10000, '영화') 	# 20% 할인해서
		- print 기능 (print)
		
	class Movie_Card:
	    def __init__(self):
	        self.card = 0
	        
	    def charge(self, num):
	        self.card += num
	        print('{}원 충전되었습니다.'.format(num))
	    
	    def consume(self, num, loc):
	        if loc == '영화관':
	            num = int(num*0.8)
	        self.card -= num
	        if self.card <= 0:
	            print('잔액이 부족합니다.')
	        else:
	            print('{}에서 {}원 사용했습니다.'.format(loc, num))
	
	    def print(self):
	        print('잔액이 {}원 입니다.'.format(self.card))
	        
	card1 = Movie_Card()    
	
	card1.charge(20000)
	card1.print()
	
	card1.consume(3000,'마트')
	card1.consume(10000, '영화관')
	card1.print()
	card1.consume(13000, '마트')
	
	20000원 충전되었습니다.
	잔액이 20000원 입니다.
	마트에서 3000원 사용했습니다.
	영화관에서 8000원 사용했습니다.
	잔액이 9000원 입니다.
	잔액이 부족합니다.
























































